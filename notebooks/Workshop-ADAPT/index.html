<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tutorial - Adaptive State Preparation Techniques &mdash; Quantum Autumn School 2023  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/togglebutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sphinx_lesson.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sphinx_rtd_theme_ext_color_contrast.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/tabs.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/overrides.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
        <script src="../../_static/minipres.js"></script>
        <script>let toggleHintShow = 'Click to show';</script>
        <script>let toggleHintHide = 'Click to hide';</script>
        <script>let toggleOpenOnPrint = 'true';</script>
        <script src="../../_static/togglebutton.js"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
        <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script data-domain="enccs.github.io/qas2023" defer="defer" src="https://plausible.io/js/script.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex/" />
    <link rel="search" title="Search" href="../../search/" />
    <link rel="next" title="Tutorial - Quantum support vector regression for disability insurance" href="../QF/" />
    <link rel="prev" title="Tutorial - Quantum chemistry" href="../E2_VQE-H2/" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../" class="icon icon-home">
            Quantum Autumn School 2023
              <img src="../../_static/ENCCS.jpg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Setup</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../setup/">Setup</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Day 1</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../qc-overview/">Physical Approaches to Quantum Computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../digital-qc/">Introduction to Digital Quantum Computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../E1_qc-1/">Tutorial - Quantum programming I</a></li>
<li class="toctree-l1"><a class="reference internal" href="../E1_qc-2/">Tutorial - Quantum programming II</a></li>
<li class="toctree-l1"><a class="reference internal" href="../E1_qc-3/">Tutorial - Quantum programming III</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Day 2</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../hpc-qc/">HPC-QC integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../software-stack/">QC software stack</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hybrid-classical-quantum/">Hybrid Classical/Quantum Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro-to-helmi-qiskit/">Tutorial - Introduction to Helmi with qiskit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Qubit_Spectroscopy_Analysis/">Tutorial - Qubit Spectroscopy Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Notebook_maxcut_Qas2023/">Tutorial - Quantum Alternating Operator Ansatz</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Day 3</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../hybrid-quantum-chemistry/">Hybrid Algorithms - Use Cases for Quantum Chemistry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hybrid-finance/">Hybrid Algorithms - Use Cases for Quantum Finance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hybrid-life-science/">Hybrid Algorithms - Use Cases for Quantum Life Science</a></li>
<li class="toctree-l1"><a class="reference internal" href="../E2_VQE-H2/">Tutorial - Quantum chemistry</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorial - Adaptive State Preparation Techniques</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#active-space-methods-in-quantum-chemistry">Active space methods in quantum chemistry</a></li>
<li class="toctree-l2"><a class="reference internal" href="#adaptive-state-preparation">Adaptive state preparation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#select-molecule-and-obtain-fermionic-hamiltonian">Select molecule and obtain fermionic hamiltonian</a></li>
<li class="toctree-l2"><a class="reference internal" href="#choose-a-qubit-converter-and-map-the-fermionic-hamiltonian-to-qubit-space">Choose a qubit converter and map the fermionic Hamiltonian to qubit space</a></li>
<li class="toctree-l2"><a class="reference internal" href="#initialise-additional-operators">Initialise additional operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="#choose-an-operator-pool">Choose an operator pool</a></li>
<li class="toctree-l2"><a class="reference internal" href="#initialize-ansatz">Initialize Ansatz</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#transpile-and-draw-ansatz">Transpile and draw ansatz</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#choose-optimizer-method-and-optimizer-object">Choose optimizer method and optimizer object</a></li>
<li class="toctree-l2"><a class="reference internal" href="#initialize-the-adapt-vqe-class">Initialize the ADAPT-VQE class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#run-adapt-algorithm">Run ADAPT algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#plot-stats-from-simulation">Plot stats from simulation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../QF/">Tutorial - Quantum support vector regression for disability insurance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Tutotial_HPCoordinateBasedLattice_noDependencies/">Tutorial: Protein Folding with Quantum Approximate Optimization Algorithm (QAOA)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://enccs.se/lessons/">All ENCCS lessons</a></li>
<li class="toctree-l1"><a class="reference external" href="https://enccs.se/">About ENCCS</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../">Quantum Autumn School 2023</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Tutorial - Adaptive State Preparation Techniques</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/ENCCS/qas2023/blob/main/content/notebooks/Workshop-ADAPT.ipynb" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="tutorial-adaptive-state-preparation-techniques">
<h1>Tutorial - Adaptive State Preparation Techniques<a class="headerlink" href="#tutorial-adaptive-state-preparation-techniques" title="Permalink to this heading"></a></h1>
<section id="active-space-methods-in-quantum-chemistry">
<h2>Active space methods in quantum chemistry<a class="headerlink" href="#active-space-methods-in-quantum-chemistry" title="Permalink to this heading"></a></h2>
<p>Most quantum chemistry simulations assume that a single Slater determinant (the <em>reference</em>) gives a <em>qualitatively</em> accurate description of the electronic structure of the system. When such as assumption is correct, going beyond a qualitative description can be achieved by adding further Slater determinants. These additional Slater determinants are built systematically by exciting simultaneously one, two, or more electrons from the occupied to the unoccupied (or virtual) molecular orbitals, <em>i.e.</em> the optimized one-electron basis functions.</p>
<img alt="../../_images/excitations.png" src="../../_images/excitations.png" />
<p>Including all possible excitation ranks from/to all possible orbitals generates the <em>full configuration interaction</em> (FCI) wavefunction, which is the exact ground state for the given molecular Hamiltonian in the given atomic orbital basis. Clearly, inclusion of all Slater determinants scales exponentially and is feasible only for quite small systems.</p>
<p>However, it’s usually not necessary to resort to FCI. This is because a better qualitative description can be obtained by correlating a <em>subset</em> only of orbitals and electrons, leading to so-called <em>active space methods</em>.</p>
<img alt="../../_images/CAS.png" src="../../_images/CAS.png" />
<p>The <em>complete active space</em> (CAS) family of methods is the most common. The user selects, usually guided by chemical intuition, relevant subsets of <span class="math notranslate nohighlight">\(N\)</span> electrons and <span class="math notranslate nohighlight">\(M\)</span> orbitals to correlate. In the jargon, this is a CAS(<span class="math notranslate nohighlight">\(N\)</span>,<span class="math notranslate nohighlight">\(M\)</span>) calculation. The wavefunction expansion is constructed as a linear combination of all determinants which include all possible excitations within the selected subspace. Further, if the one-particle basis is optimized simultaneously with the expansion coefficients, the methods is called <em>complete active space self-consistent field</em> (CASSCF). Otherwise, it is called <em>complete active space configuration interaction</em> (CASCI).</p>
</section>
<section id="adaptive-state-preparation">
<h2>Adaptive state preparation<a class="headerlink" href="#adaptive-state-preparation" title="Permalink to this heading"></a></h2>
<p>The previous example for <span class="math notranslate nohighlight">\(H_2\)</span> started from an <em>a priori</em> fixed structure of the wavefunction ansatz, leaving parameters free for optimization through the joing work of quantum and classical subroutines. While a fixed ansatz structure gives us the tools to bound the requirements on the quantum hardware, both in terms of number of qubits and circuit depth, it might suffer from lack of flexibility and make it difficult to optimize the free parameters in a reasonable number of steps.</p>
<p>The key feature of ADAPT-VQE is that the circuit is built adaptively for the problem at hand, instead of having a fixed ansatz structure.</p>
<p>At iteration <span class="math notranslate nohighlight">\(n\)</span>, the ansatz construction step in ADAPT-VQE adds a unitary operator <span class="math notranslate nohighlight">\(e^{\theta_i P_i}\)</span> to the current circuit <span class="math notranslate nohighlight">\(| \psi^{(n-1)} (\vec{\theta}^{(n-1)}) \rangle\)</span>, so that the resulting circuit prepares the state:</p>
<div class="math notranslate nohighlight">
\[| \psi^{(n)} (\vec{\theta}^{(n)})  \rangle = e^{\theta_i P_i} | \psi^{(n-1)} (\vec{\theta}^{(n-1)}) \rangle,\]</div>
<p>where <span class="math notranslate nohighlight">\(\vec{\theta}^{(n)}\)</span> indicates the set of <span class="math notranslate nohighlight">\(n\)</span> parameters in the ansatz at iteration <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>The operator <span class="math notranslate nohighlight">\(P_i\)</span> is chosen from a <strong>pool of operators</strong> that is defined beforehand.
To determine which element should be chosen from the pool, one needs to perform a series of measurements for each of them, which results in the measurement overhead mentioned in the lecture.</p>
<p>Once the operator is added, the new variational circuit,</p>
<div class="math notranslate nohighlight">
\[\ket{\psi^{(n)} (\vec{\theta}^{(n)})} = \prod\limits_{i = 1}^n e^{\theta_i P_i} \ket{\psi^{(0)}},\]</div>
<p>where <span class="math notranslate nohighlight">\(| \psi^{(0)} \rangle\)</span> is an initial reference state (usually the Hartree-Fock state), is variationally optimised with respect to the set of parameters <span class="math notranslate nohighlight">\(\vec{\theta}^{(n)}\)</span>.</p>
<p>For more theory, refer to the following articles:</p>
<ul class="simple">
<li><p>Original ADAPT: https://www.nature.com/articles/s41467-019-10988-2</p></li>
<li><p>q-ADAPT: https://link.aps.org/doi/10.1103/PRXQuantum.2.020310</p></li>
<li><p>QEB: https://arxiv.org/abs/2011.10540</p></li>
<li><p>AIM-ADAPT: https://arxiv.org/abs/2212.09719</p></li>
</ul>
<p>In the following, we will use <code class="docutils literal notranslate"><span class="pre">aurora</span></code>, the codebase we’re developing at Algorithmiq, to run various flavors of VQE routines.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">aurora</span></code> codebase uses Python logging to output information during execution. So the first step is to set the logging levels to obtain a reasonable amount of output to understand what is going on.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">logging</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span>
    <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%(asctime)s</span><span class="s2">:</span><span class="si">%(filename)s</span><span class="s2">:</span><span class="si">%(levelname)s</span><span class="s2">:</span><span class="si">%(message)s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">WARNING</span>
<span class="p">)</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;aurora&quot;</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We also need to import relevant modules and functions</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">aurora.chemistry.eos.eos_pyscf</span> <span class="kn">import</span> <span class="n">EOSpyscf</span> <span class="k">as</span> <span class="n">eos</span>
<span class="kn">from</span> <span class="nn">aurora.chemistry.eos.utils</span> <span class="kn">import</span> <span class="n">get_qiskit_esp</span>
<span class="kn">from</span> <span class="nn">aurora.utils</span> <span class="kn">import</span> <span class="n">from_qiskit_operator</span><span class="p">,</span> <span class="n">to_qiskit_operator</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="select-molecule-and-obtain-fermionic-hamiltonian">
<h2>Select molecule and obtain fermionic hamiltonian<a class="headerlink" href="#select-molecule-and-obtain-fermionic-hamiltonian" title="Permalink to this heading"></a></h2>
<p>First we need to choose the molecule and get Hamiltonian. The fermionic hamiltonian is</p>
<div class="math notranslate nohighlight">
\[H = \sum_{p, q} h_{p q} a_q^{\dagger} a_p+\frac{1}{2} \sum_{p, q, r, s} h_{p q r s} a_p^{\dagger} a_q^{\dagger} a_s a_r,\]</div>
<p>where <span class="math notranslate nohighlight">\(a_p^{\dagger}\)</span> and <span class="math notranslate nohighlight">\(a_p\)</span> are the fermionic creation and annihilation operators, <span class="math notranslate nohighlight">\( h_{p q}\)</span> and <span class="math notranslate nohighlight">\(h_{p q r s}\)</span> are one- and two-electron integrals, and <span class="math notranslate nohighlight">\(p,q,r\)</span> and <span class="math notranslate nohighlight">\(s\)</span> are spin-orbital indices. The Hamiltonian can be obtained trough the EOS package in Aurora as shown in the next cell.</p>
<p>The following function encodes data for a few example molecules.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_molecule</span><span class="p">(</span>
    <span class="n">molecule_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;H4&quot;</span><span class="p">,</span> <span class="n">basis</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sto3g&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">eos</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="k">match</span> <span class="n">molecule_name</span><span class="p">:</span>
        <span class="k">case</span> <span class="s2">&quot;H2&quot;</span><span class="p">:</span>
            <span class="n">bond_distance</span> <span class="o">=</span> <span class="mf">0.75</span>

            <span class="n">mymol</span> <span class="o">=</span> <span class="n">eos</span><span class="p">(</span>
                <span class="n">atoms</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;H 0 0 0; H 0 0 </span><span class="si">{</span><span class="n">bond_distance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">,</span>
                <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">spin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">num_particles</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">num_active_orbitals</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">num_inactive_orbitals</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">case</span> <span class="s2">&quot;H4&quot;</span><span class="p">:</span>
            <span class="n">bond_distance</span> <span class="o">=</span> <span class="mf">1.5</span>

            <span class="n">mymol</span> <span class="o">=</span> <span class="n">eos</span><span class="p">(</span>
                <span class="n">atoms</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;H 0 0 0; H 0 0 </span><span class="si">{</span><span class="n">bond_distance</span><span class="si">}</span><span class="s2">; H 0 0 </span><span class="si">{</span><span class="n">bond_distance</span><span class="o">*</span><span class="mi">2</span><span class="si">}</span><span class="s2">; H 0 0 </span><span class="si">{</span><span class="n">bond_distance</span><span class="o">*</span><span class="mi">3</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">,</span>
                <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">spin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">num_particles</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">num_active_orbitals</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="n">num_inactive_orbitals</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">case</span> <span class="s2">&quot;H4-square&quot;</span><span class="p">:</span>
            <span class="n">bond_distance</span> <span class="o">=</span> <span class="mf">2.0</span>

            <span class="n">mymol</span> <span class="o">=</span> <span class="n">eos</span><span class="p">(</span>
                <span class="n">atoms</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;H 0 0 0; H 0 0 </span><span class="si">{</span><span class="n">bond_distance</span><span class="si">}</span><span class="s2">; H 0 </span><span class="si">{</span><span class="n">bond_distance</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">bond_distance</span><span class="si">}</span><span class="s2">; H 0 </span><span class="si">{</span><span class="n">bond_distance</span><span class="si">}</span><span class="s2"> 0&quot;</span><span class="p">,</span>
                <span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">,</span>
                <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">spin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">num_particles</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">num_active_orbitals</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="n">num_inactive_orbitals</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">case</span> <span class="s2">&quot;H5&quot;</span><span class="p">:</span>
            <span class="n">bond_distance</span> <span class="o">=</span> <span class="mf">1.5</span>

            <span class="n">mymol</span> <span class="o">=</span> <span class="n">eos</span><span class="p">(</span>
                <span class="n">atoms</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;H 0 0 0; H 0 0 </span><span class="si">{</span><span class="n">bond_distance</span><span class="si">}</span><span class="s2">; H 0 0 </span><span class="si">{</span><span class="n">bond_distance</span><span class="o">*</span><span class="mi">2</span><span class="si">}</span><span class="s2">; H 0 0 </span><span class="si">{</span><span class="n">bond_distance</span><span class="o">*</span><span class="mi">3</span><span class="si">}</span><span class="s2">; H 0 0 </span><span class="si">{</span><span class="n">bond_distance</span><span class="o">*</span><span class="mi">4</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">,</span>
                <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">num_particles</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">num_active_orbitals</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="n">num_inactive_orbitals</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">case</span> <span class="s2">&quot;LiH&quot;</span><span class="p">:</span>
            <span class="n">bond_distance</span> <span class="o">=</span> <span class="mf">1.5</span>

            <span class="n">mymol</span> <span class="o">=</span> <span class="n">eos</span><span class="p">(</span>
                <span class="n">atoms</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Li 0 0 0; H 0 0 </span><span class="si">{</span><span class="n">bond_distance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>

            <span class="n">num_particles</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">num_active_orbitals</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="n">num_inactive_orbitals</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Molecule </span><span class="si">{</span><span class="n">molecule_name</span><span class="si">}</span><span class="s2"> unrecognized.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mymol</span><span class="p">,</span> <span class="n">num_particles</span><span class="p">,</span> <span class="n">num_active_orbitals</span><span class="p">,</span> <span class="n">num_inactive_orbitals</span>
</pre></div>
</div>
</div>
</div>
<p>We can just call it with the  desired <code class="docutils literal notranslate"><span class="pre">molecule_name</span></code>. The function will run a calculation to obtain the reference single determinant and the molecular integrals in the corresponding molecular orbital basis.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mymol</span><span class="p">,</span> <span class="n">num_particles</span><span class="p">,</span> <span class="n">num_active_orbitals</span><span class="p">,</span> <span class="n">num_inactive_orbitals</span> <span class="o">=</span> <span class="n">get_molecule</span><span class="p">(</span>
    <span class="s2">&quot;H4&quot;</span><span class="p">,</span> <span class="s2">&quot;sto3g&quot;</span>
<span class="p">)</span>
<span class="c1"># Setup Hartree-Fock problem and run it</span>
<span class="n">mymol</span><span class="o">.</span><span class="n">set_scf</span><span class="p">()</span>
<span class="c1"># Get SCF object</span>
<span class="n">myscf</span> <span class="o">=</span> <span class="n">mymol</span><span class="o">.</span><span class="n">get_scf</span><span class="p">()</span>
<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Electronic energy: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">myscf</span><span class="o">.</span><span class="n">energy_elec</span><span class="p">())</span>

<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Hartree-Fock occupation numbers: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">myscf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">)</span>


<span class="c1"># Setup CAS problem and run it</span>

<span class="n">mymol</span><span class="o">.</span><span class="n">set_cas</span><span class="p">(</span>
    <span class="n">myscf</span><span class="p">,</span>
    <span class="n">nisht</span><span class="o">=</span><span class="n">num_inactive_orbitals</span><span class="p">,</span>
    <span class="n">nasht</span><span class="o">=</span><span class="n">num_active_orbitals</span><span class="p">,</span>
    <span class="n">nalpha</span><span class="o">=</span><span class="n">num_particles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="n">nbeta</span><span class="o">=</span><span class="n">num_particles</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="n">optimize_orbitals</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">)</span>


<span class="c1"># Run CAS object</span>
<span class="n">mycas</span> <span class="o">=</span> <span class="n">mymol</span><span class="o">.</span><span class="n">run_cas</span><span class="p">()</span>

<span class="n">prob</span> <span class="o">=</span> <span class="n">get_qiskit_esp</span><span class="p">(</span>
    <span class="n">mymol</span><span class="o">.</span><span class="n">get_active_h1</span><span class="p">(),</span>
    <span class="n">mymol</span><span class="o">.</span><span class="n">get_active_h2</span><span class="p">(),</span>
    <span class="n">myscf</span><span class="o">.</span><span class="n">energy_elec</span><span class="p">(),</span>
    <span class="n">num_active_orbitals</span><span class="p">,</span>
    <span class="nb">sum</span><span class="p">(</span><span class="n">num_particles</span><span class="p">),</span>
<span class="p">)</span>

<span class="c1"># Get fermionic hamiltonian</span>
<span class="n">qc_ham_qiskit</span> <span class="o">=</span> <span class="n">prob</span><span class="o">.</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">second_q_op</span><span class="p">()</span>

<span class="c1"># Get the exact electronic energy</span>
<span class="n">exact_energy</span> <span class="o">=</span> <span class="n">mymol</span><span class="o">.</span><span class="n">get_etot</span><span class="p">()</span> <span class="o">-</span> <span class="n">mymol</span><span class="o">.</span><span class="n">get_ecore</span><span class="p">()</span>
<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Exact energy: </span><span class="si">%20.14f</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">exact_energy</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="choose-a-qubit-converter-and-map-the-fermionic-hamiltonian-to-qubit-space">
<h2>Choose a qubit converter and map the fermionic Hamiltonian to qubit space<a class="headerlink" href="#choose-a-qubit-converter-and-map-the-fermionic-hamiltonian-to-qubit-space" title="Permalink to this heading"></a></h2>
<p>Once we have obtained the fermionic Hamiltonian, we need to transform it to qubit space. The <em>fermion to qubit</em> (F2Q) mapping is not unique and you can explore different options.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit_nature.second_q.mappers</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">JordanWignerMapper</span><span class="p">,</span>
    <span class="n">QubitConverter</span><span class="p">,</span>
    <span class="n">BravyiKitaevMapper</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">aurora.mappers.neven</span> <span class="kn">import</span> <span class="n">NevenMapper</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Mapper options: JordanWignerMapper(), BravyiKitaevMapper(), ParityMapper(), NevenMapper()</span>
<span class="n">qubit_converter</span> <span class="o">=</span> <span class="n">QubitConverter</span><span class="p">(</span><span class="n">mapper</span><span class="o">=</span><span class="n">JordanWignerMapper</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Convert fermionic Hamiltonian to qubit space</span>
<span class="n">hamiltonian_qiskit</span> <span class="o">=</span> <span class="n">qubit_converter</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">qc_ham_qiskit</span><span class="p">,</span> <span class="n">num_particles</span><span class="o">=</span><span class="n">num_particles</span><span class="p">)</span>
<span class="n">num_qubits</span> <span class="o">=</span> <span class="n">hamiltonian_qiskit</span><span class="o">.</span><span class="n">num_qubits</span>
<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Number of qubits: </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">num_qubits</span><span class="p">)</span>

<span class="c1"># Transform Qiskit operator into an Aurora operator (dictionary)</span>
<span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">from_qiskit_operator</span><span class="p">(</span><span class="n">hamiltonian_qiskit</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="initialise-additional-operators">
<h2>Initialise additional operators<a class="headerlink" href="#initialise-additional-operators" title="Permalink to this heading"></a></h2>
<p>It is possible to consider additional operators in the VQE routines. These are usually added as penalty terms to the Hamiltonian:</p>
<div class="math notranslate nohighlight">
\[
F(\vec{\theta}) = 
\left\langle \psi(\vec{\theta}) \left| H \right| \psi(\vec{\theta}) \right\rangle
+
\sum_{i}\mu_{i} \left[\left\langle \psi(\vec{\theta}) \left| O_i \right| \psi(\vec{\theta}) \right\rangle - o_i
 \right]^{2},
\]</div>
<p>such that we can constrain the state to, approximately, be an eigenfunction of the <span class="math notranslate nohighlight">\(\hat{O}_i\)</span> operators with prescribed eigenvalue <span class="math notranslate nohighlight">\(o_i\)</span>.
This is useful to enforce a given total spin or number of particles. Our ADAPT-VQE class can also simply measure them at each step, to monitor their value during the VQE routine.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">aurora.state.operators</span> <span class="kn">import</span> <span class="n">spin2_error_operator</span><span class="p">,</span> <span class="n">number_error_operator</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set correct spin-2 and particle number values</span>
<span class="n">spin2_value</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># s(s+1)</span>
<span class="n">number_value</span> <span class="o">=</span> <span class="mi">4</span> <span class="c1"># sum(num_particles)</span>

<span class="n">spin_penalty</span> <span class="o">=</span> <span class="n">spin2_error_operator</span><span class="p">(</span>
    <span class="n">num_qubits</span><span class="o">=</span><span class="n">num_qubits</span><span class="p">,</span>
    <span class="n">spin2_value</span><span class="o">=</span><span class="n">spin2_value</span><span class="p">,</span>
    <span class="n">qubit_converter</span><span class="o">=</span><span class="n">qubit_converter</span><span class="p">,</span>
    <span class="n">num_particles</span><span class="o">=</span><span class="n">num_particles</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">num_penalty</span> <span class="o">=</span> <span class="n">number_error_operator</span><span class="p">(</span>
    <span class="n">num_qubits</span><span class="o">=</span><span class="n">num_qubits</span><span class="p">,</span>
    <span class="n">number_value</span><span class="o">=</span><span class="n">number_value</span><span class="p">,</span>
    <span class="n">qubit_converter</span><span class="o">=</span><span class="n">qubit_converter</span><span class="p">,</span>
    <span class="n">num_particles</span><span class="o">=</span><span class="n">num_particles</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="choose-an-operator-pool">
<h2>Choose an operator pool<a class="headerlink" href="#choose-an-operator-pool" title="Permalink to this heading"></a></h2>
<p>At each iteration, ADAPT-VQE will measure the gradient of the objective function with respect to all operators in the chosen operator pool and add to the Ansatz the operator with largest gradient.</p>
<p>The original ADAPT pool consists of spin-complemented fermionic single and double excitations as follows:</p>
<div class="math notranslate nohighlight">
\[\mathcal{P} =
\{ \tau_{p_{\alpha}}^{q_{\alpha}} + \tau_{p_{\beta}}^{q_{\beta}}, \tau_{r_{\alpha} s_{\alpha}}^{p_{\alpha} q_{\alpha}} + \tau_{r_{\beta} s_{\beta}}^{p_{\beta} q_{\beta}},
\tau_{r_{\alpha} s_{\beta}}^{p_{\alpha} q_{\beta}} + 
\tau_{r_{\beta} s_{\alpha}}^{p_{\beta} q_{\alpha}}\},
\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{\tau}_p^q = a_q^{\dagger} a_p-a_p^{\dagger} a_q\)</span> and <span class="math notranslate nohighlight">\(\hat{\tau}_{r s}^{p q} = a_p^{\dagger} a_q^{\dagger} a_r a_s-a_s^{\dagger} a_r^{\dagger} a_q a_p\)</span> and <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> indices indicate the spin orientation of the spin-orbital. Spin-complemented operators conserve particle number and spin symmetries, although Trotterisation of the operators can break spin symmetry.</p>
<p>A spin-dependent version of the fermionic pool is following:</p>
<div class="math notranslate nohighlight">
\[\mathcal{P}_{spin} =
\{ \tau_{p_{\alpha}}^{q_{\alpha}}, \tau_{p_{\beta}}^{q_{\beta}}, \tau_{r_{\alpha} s_{\alpha}}^{p_{\alpha} q_{\alpha}}, \tau_{r_{\beta} s_{\beta}}^{p_{\beta} q_{\beta}},
\tau_{r_{\alpha} s_{\beta}}^{p_{\alpha} q_{\beta}},
\tau_{r_{\beta} s_{\alpha}}^{p_{\beta} q_{\alpha}}\},
\]</div>
<p>This pool conserves <span class="math notranslate nohighlight">\(S_z\)</span> and <span class="math notranslate nohighlight">\(N\)</span> symmetries but can break the <span class="math notranslate nohighlight">\(S^2\)</span> symmetry.</p>
<p>A Qubit Excitation Based (QEB) pool is a fermionic pool in Jordan-Wigner mapping where the Z-string (that keep track of fermionic anti-symmetries) are removed. It is a more hardware efficient pool for all-to-all connectivity devices, but the Z-string removal does have an increasing effect on the convergence.</p>
<p>A q-ADAPT pool is formed by mapping a spin-dependent fermionic pool (or QEB pool) into qubit space, <span class="math notranslate nohighlight">\(\tau \mapsto \sum_k c_k S_k\)</span>, with <span class="math notranslate nohighlight">\(\tau \in \mathcal{P}\)</span> and <span class="math notranslate nohighlight">\(S_k \in \{ \mathbb{I}, X, Y, Z \}^{\otimes N}\)</span>, and splitting the resulting operators into separate terms. This creates the qubit-ADAPT pool, defined in qubits space in terms of the operators <span class="math notranslate nohighlight">\(P_k = i S_k\)</span>. q-ADAPT pool breaks particle number and spin symmetries.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">aurora.state.operators</span> <span class="kn">import</span> <span class="n">get_operator_pool</span>
</pre></div>
</div>
</div>
</div>
<p>We can test the following operator pools: <code class="docutils literal notranslate"><span class="pre">'fermionic'</span></code>, <code class="docutils literal notranslate"><span class="pre">'fermionic_spin'</span></code>, <code class="docutils literal notranslate"><span class="pre">'QEB'</span></code>, <code class="docutils literal notranslate"><span class="pre">'q-ADAPT'</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">operator_pool</span> <span class="o">=</span> <span class="n">get_operator_pool</span><span class="p">(</span>
    <span class="n">operator_type</span><span class="o">=</span><span class="s2">&quot;q-ADAPT&quot;</span><span class="p">,</span>  <span class="c1"># Set the operator type here</span>
    <span class="n">num_qubits</span><span class="o">=</span><span class="n">num_qubits</span><span class="p">,</span>
    <span class="n">qubit_converter</span><span class="o">=</span><span class="n">qubit_converter</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Num operators: </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">operator_pool</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Print elements from the operator pool. Each element is a tuple where the 1st element is the operator, represented as a linear combination of Pauli strings, and the 2nd is the corresponding gate.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">operator_pool</span><span class="p">[</span><span class="mi">25</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="initialize-ansatz">
<h2>Initialize Ansatz<a class="headerlink" href="#initialize-ansatz" title="Permalink to this heading"></a></h2>
<p>We need to select an initial state for the ADAPT-VQE procedure, similarly to what was done for the <span class="math notranslate nohighlight">\(H_2\)</span> example with a fixed Ansatz. The common thing to do is to start from the Hartree-Fock reference determinant.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">aurora.state.utils</span> <span class="kn">import</span> <span class="n">estimate_operator_exact</span>
<span class="kn">from</span> <span class="nn">aurora.state.constructors</span> <span class="kn">import</span> <span class="n">hartree_fock_ansatz</span>
<span class="kn">from</span> <span class="nn">aurora.state.converters.qiskit_converter</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ansatz_to_qiskit_circuit</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Once again, the circuit corresponding to the initial state will depend on the F2Q mapper used.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Initialize in HF state</span>
<span class="n">ansatz</span> <span class="o">=</span> <span class="n">hartree_fock_ansatz</span><span class="p">(</span>
    <span class="n">num_spatial_orbitals</span><span class="o">=</span><span class="n">num_qubits</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">num_particles</span><span class="o">=</span><span class="n">num_particles</span><span class="p">,</span>
    <span class="n">mapper</span><span class="o">=</span><span class="n">JordanWignerMapper</span><span class="p">(),</span>  <span class="c1"># BravyiKitaevMapper(), ParityMapper(), NevenMapper()</span>
<span class="p">)</span>

<span class="c1"># Measure HF energy</span>
<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Initial energy: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">estimate_operator_exact</span><span class="p">(</span><span class="n">ansatz</span><span class="p">,</span> <span class="n">hamiltonian</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<section id="transpile-and-draw-ansatz">
<h3>Transpile and draw ansatz<a class="headerlink" href="#transpile-and-draw-ansatz" title="Permalink to this heading"></a></h3>
<p>The generated ansatz has to be <em>transpiled</em> to a circuit, before being executated on quantum hardware or a simulator.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">aurora.state.custom_transpilers</span> <span class="kn">import</span> <span class="n">qiskit_transpiler</span>
</pre></div>
</div>
</div>
</div>
<p>At any point, you can draw the resulting circuit to inspect which gates have been added at each step of the ADAPT procedure.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">transpiler</span> <span class="o">=</span> <span class="n">qiskit_transpiler</span><span class="p">()</span>
<span class="n">ansatz_to_qiskit_circuit</span><span class="p">(</span><span class="n">transpiler</span><span class="o">.</span><span class="n">transpile</span><span class="p">(</span><span class="n">ansatz</span><span class="p">))</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="choose-optimizer-method-and-optimizer-object">
<h2>Choose optimizer method and optimizer object<a class="headerlink" href="#choose-optimizer-method-and-optimizer-object" title="Permalink to this heading"></a></h2>
<p>The quantum subroutine is complemented by classical optimization to update the free parameters in the circuit gates. In principle, any classical optimization method will do.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.algorithms.optimizers</span> <span class="kn">import</span> <span class="n">COBYLA</span><span class="p">,</span> <span class="n">L_BFGS_B</span><span class="p">,</span> <span class="n">SLSQP</span><span class="p">,</span> <span class="n">SPSA</span><span class="p">,</span> <span class="n">GradientDescent</span>
<span class="kn">from</span> <span class="nn">aurora.state.optimizers</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">OptimizerStatevector</span><span class="p">,</span>
    <span class="n">OptimizerPOVMs</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The classical optimizer will be used within an <code class="docutils literal notranslate"><span class="pre">Optimizer</span></code> object in <code class="docutils literal notranslate"><span class="pre">aurora</span></code>. This object will be responsible for “translating” the outcomes from the quantum hardware to values/gradients of the objective function, as understood by the classical optimization routine.</p>
<p>For example, when using statevector simulations, it is appropriate to use a classical optimization routine with an <code class="docutils literal notranslate"><span class="pre">OptimizerStatevector</span></code> object, which knows how to compute expectation values of the Hamiltonian and the gradients needed in ADAPT-VQE.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">OptimizerPOVMs</span></code> object is appropriate when using informationally complete (IC) POVM measurements, either with a noisy simulator or with quantum hardware.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Choose the method</span>

<span class="n">optimizer_method</span> <span class="o">=</span> <span class="n">L_BFGS_B</span><span class="p">(</span><span class="n">maxfun</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;disp&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;gtol&quot;</span><span class="p">:</span> <span class="mf">1e-5</span><span class="p">})</span>
<span class="c1"># optimizer_method = &quot;BFGS&quot;</span>
<span class="c1"># optimizer_method = COBYLA(maxiter=1000, disp=True)</span>
<span class="c1"># optimizer_method = SPSA()</span>
<span class="c1"># optimizer_method = GradientDescent(maxiter=10)</span>

<span class="c1"># Choose the object</span>

<span class="n">optimizer</span> <span class="o">=</span> <span class="n">OptimizerStatevector</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer_method</span><span class="p">)</span>
<span class="c1"># optimizer = OptimizerPOVMs(optimizer=optimizer_method)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="initialize-the-adapt-vqe-class">
<h2>Initialize the ADAPT-VQE class<a class="headerlink" href="#initialize-the-adapt-vqe-class" title="Permalink to this heading"></a></h2>
<p>We’re now finally ready to initialize the ADAPT-VQE class, which is called <code class="docutils literal notranslate"><span class="pre">RiemannianFlow</span></code>. The class can handle either statevector simulations or IC-POVM quantum measurements.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">aurora.state.constructors</span> <span class="kn">import</span> <span class="n">RiemannianFlow</span>
<span class="kn">from</span> <span class="nn">aurora.measurement.estimator.local_povm_estimator</span> <span class="kn">import</span> <span class="n">LocalPOVMEstimator</span>
<span class="kn">from</span> <span class="nn">aurora.measurement.povm.local_dilation_povm</span> <span class="kn">import</span> <span class="n">LocalDilationPOVM</span>
<span class="kn">from</span> <span class="nn">aurora.measurement.povm.joint_povm</span> <span class="kn">import</span> <span class="n">JointPOVM</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
</div>
<p>Initialize <code class="docutils literal notranslate"><span class="pre">JointPOVM</span></code> if working with measurements</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">povm_list</span> <span class="o">=</span> <span class="n">JointPOVM</span><span class="p">(</span><span class="n">LocalDilationPOVM</span><span class="p">(),</span> <span class="n">num_qubits</span><span class="o">=</span><span class="n">num_qubits</span><span class="p">)</span>
<span class="n">estimator</span> <span class="o">=</span> <span class="n">LocalPOVMEstimator</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">povm</span><span class="o">.</span><span class="n">effects</span> <span class="k">for</span> <span class="n">povm</span> <span class="ow">in</span> <span class="n">povm_list</span><span class="p">]))</span>
</pre></div>
</div>
</div>
</div>
<p>Choose statevector or POVM measurements. Input <code class="docutils literal notranslate"><span class="pre">JointPOVM</span></code> and <code class="docutils literal notranslate"><span class="pre">Estimator</span></code> if POVMs are used.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Initialise RiemannianFlow object. Choose measurement type and pass POVMs and Estimator if working with measurements</span>

<span class="n">riemannian_flow</span> <span class="o">=</span> <span class="n">RiemannianFlow</span><span class="p">(</span>
    <span class="n">ansatz</span><span class="o">=</span><span class="n">ansatz</span><span class="p">,</span>
    <span class="n">hamiltonian</span><span class="o">=</span><span class="n">hamiltonian</span><span class="p">,</span>
    <span class="n">operator_pool</span><span class="o">=</span><span class="n">operator_pool</span><span class="p">,</span>
    <span class="n">additional_operators</span><span class="o">=</span><span class="p">[</span><span class="n">spin_penalty</span><span class="p">,</span> <span class="n">num_penalty</span><span class="p">],</span>
    <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
    <span class="n">measurement_type</span><span class="o">=</span><span class="s2">&quot;statevector&quot;</span><span class="p">,</span>
    <span class="n">optimization_type</span><span class="o">=</span><span class="s2">&quot;statevector&quot;</span><span class="p">,</span>
    <span class="c1"># povm_list=povm_list,</span>
    <span class="c1"># estimator=estimator,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="run-adapt-algorithm">
<h2>Run ADAPT algorithm<a class="headerlink" href="#run-adapt-algorithm" title="Permalink to this heading"></a></h2>
<p>The operator selection can be done in many ways.
Ideally, the aim is to add gates that have maximum effect in taking the state towards the ground state of the system.
A heuristic to this end is based on the gradient of the energy with respect to the parameter in the unitary generated by operator <span class="math notranslate nohighlight">\(P_i\)</span> when the parameter value is set to zero, which can be calculated by evaluating the commutator of <span class="math notranslate nohighlight">\(P_i\)</span> with the Hamiltonian,</p>
<div class="math notranslate nohighlight">
\[ \left.\frac{\partial E}{\partial \theta_i}\right|_{\theta_i=0} =\left.\left[\frac{\partial}{\partial \theta_i}\left\langle\psi^{(n)}\left|e^{-\theta_i P_i} H e^{\theta_i P_i}\right| \psi^{(n)}\right\rangle\right]\right|_{\theta_i=0} 
=\left\langle\psi^{(n)}\left|\left[H, P_i\right]\right| \psi^{(n)}\right\rangle \]</div>
<p>Once the gradients for all the operators <span class="math notranslate nohighlight">\(P_i\)</span> in the pool have been obtained, the operator with the highest absolute value is added to the ansatz. This selection criterion is named <code class="docutils literal notranslate"><span class="pre">&quot;gradient&quot;</span></code>.</p>
<p>Another alternative is to pick the operator that decreases the energy the most. This selection criterion is named <code class="docutils literal notranslate"><span class="pre">&quot;energy&quot;</span></code>.</p>
<p>Running the cell will show a log of the ADAPT-VQE procedure and print the statevector at each iteration.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">riemannian_flow</span><span class="o">.</span><span class="n">adaptively_add_gates</span><span class="p">(</span>
    <span class="n">max_iters</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>  <span class="c1"># Max iterations before terminating</span>
    <span class="n">gates_per_iteration</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>  <span class="c1"># Gates added per iteration</span>
    <span class="n">optimization_frequency</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>  <span class="c1"># How many iterations before optimizing</span>
    <span class="n">selection_criterion</span><span class="o">=</span><span class="s2">&quot;gradient&quot;</span><span class="p">,</span> <span class="c1"># You can choose &#39;gradient&#39; or &#39;energy&#39; for operator selection criterion</span>
    <span class="n">abort_threshold</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span>  <span class="c1"># Abort when total gradient of operator pool below this</span>
    <span class="n">reference_abort_threshold</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span>  <span class="c1"># Abort when this close to reference value</span>
    <span class="n">reference_value</span><span class="o">=</span><span class="n">exact_energy</span><span class="p">,</span>  <span class="c1"># The reference value for aborting</span>
    <span class="c1"># shots = 2000000, # Shots for executions with povms</span>
    <span class="n">print_statevector</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># Print statevector</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can plot the final generated circuit, as we did for the initial state.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">transpiler</span> <span class="o">=</span> <span class="n">qiskit_transpiler</span><span class="p">()</span>
<span class="n">ansatz_to_qiskit_circuit</span><span class="p">(</span><span class="n">transpiler</span><span class="o">.</span><span class="n">transpile</span><span class="p">(</span><span class="n">ansatz</span><span class="p">))</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="plot-stats-from-simulation">
<h2>Plot stats from simulation<a class="headerlink" href="#plot-stats-from-simulation" title="Permalink to this heading"></a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
</div>
<p>Energy vs iterations</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">riemannian_flow</span><span class="o">.</span><span class="n">energies</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="n">operator_pool</span><span class="o">.</span><span class="n">operator_type</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">exact_energy</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;dashed&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Energy&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Iterations&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">mymol</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;grey&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Error to exact energy vs iterations in log plot</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">riemannian_flow</span><span class="o">.</span><span class="n">energies</span> <span class="o">-</span> <span class="n">exact_energy</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="n">operator_pool</span><span class="o">.</span><span class="n">operator_type</span>
<span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Error&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Iterations&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">mymol</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="s2">&quot;grey&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Error vs CNOT count</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">riemannian_flow</span><span class="o">.</span><span class="n">cnot_counts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">riemannian_flow</span><span class="o">.</span><span class="n">energies</span> <span class="o">-</span> <span class="n">exact_energy</span><span class="p">),</span>
    <span class="n">label</span><span class="o">=</span><span class="n">operator_pool</span><span class="o">.</span><span class="n">operator_type</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Error&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;CNOTs&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">mymol</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="s2">&quot;grey&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>First penalty term (spin-2 error) vs iterations</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">riemannian_flow</span><span class="o">.</span><span class="n">additional_operator_estimations</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="n">label</span><span class="o">=</span><span class="n">operator_pool</span><span class="o">.</span><span class="n">operator_type</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Spin Error&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Iterations&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">mymol</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="s2">&quot;grey&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Second penalty term (number error) vs iterations</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">riemannian_flow</span><span class="o">.</span><span class="n">additional_operator_estimations</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="n">label</span><span class="o">=</span><span class="n">operator_pool</span><span class="o">.</span><span class="n">operator_type</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Number Error&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Iterations&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">mymol</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="s2">&quot;grey&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../E2_VQE-H2/" class="btn btn-neutral float-left" title="Tutorial - Quantum chemistry" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../QF/" class="btn btn-neutral float-right" title="Tutorial - Quantum support vector regression for disability insurance" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, The contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>